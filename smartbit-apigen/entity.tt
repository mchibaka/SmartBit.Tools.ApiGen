<#@ import namespace="System" #>
<#@ template language="C#" #>
<#@ import namespace="Microsoft.EntityFrameworkCore.Metadata" #>
<#@ template language="C#" #>
<# 
   var model = (IModel)Session["Model"];
   var entityType = (IEntityType)Session["EntityType"]; 
   var isKeyless = entityType.FindPrimaryKey() == null;
   var clrType = entityType.ClrType;
   var entityName = clrType.Name; 
   string contextName = model.FindRuntimeAnnotation("ContextName")?.Value.ToString();
   string nsController = model.FindRuntimeAnnotation("ControllerNamespace")?.Value.ToString();
   string entityDbSetName = entityType.FindRuntimeAnnotation("DbSetName")?.Value.ToString();
#>
// <auto-generated>
//     This code was generated by a smartbit-apigen.
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using SmartBit.WeLearn360.CoreAPI.Database;
using SmartBit.WeLearn360.CoreAPI.Security;
using SmartBit.WeLearn360.CoreAPI.Common;
using System.Net;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json;

namespace <#= nsController #>;

/// <summary>
/// <#= entityName#>
/// </summary>
[Route("v1")]
[ApiController]
public partial class <#= entityName #>Controller: <#= entityName #>ControllerBase
{

    private readonly <#= contextName #> db;

    public <#= entityName #>Controller(<#= contextName #> db)
    {
        this.db = db;
    }
    
    [HttpPost()]
    [Route("api/<#= entityName #>/perform-search-<#= entityName #>")]
    [RequireSecurityToken()]
    [Produces(typeof(ICollection<<#=entityName#>Dto>))]
    public async Task<IActionResult> PerformSearchAsync(SearchCriteria criteria)
    {
        string whereClause = criteria?.WhereClause ?? "";
        int maxRows = Math.Max(criteria?.MaximumRows ?? 100, 100);

        string sqlStatement = $"SELECT TOP {maxRows} * FROM <#=!isKeyless ? entityType.GetTableName() : entityType.GetViewName()#>";
        if (!string.IsNullOrEmpty(whereClause))
        {
            sqlStatement += $" WHERE {whereClause}";
        }

        
        try
        {
            ICollection<<#=entityName#>Dto> results = await db.Database.SqlQueryRaw<<#=entityName#>Dto>
                    (sqlStatement, criteria?.Parameters).ToArrayAsync();
            return Ok(results);
        }
        catch (Exception ex)
        {
            return Problem(detail: ex.Message,
                        title: "Error searching", 
                        statusCode: (int)HttpStatusCode.InternalServerError,
                        type: ex.GetType().Name);
        }
        
    } 
    <# if(!isKeyless) { //Applies to tables only#>

    /// <summary>
    /// Adds <#=entityName#> to database for persistence 
    /// </summary>
    /// <returns></returns>
    [HttpPost()]
    [Route("api/<#=entityName#>/add-<#=entityName#>")]
    [RequireSecurityToken()]
    [Produces(typeof(<#=entityName#>Dto))]
    public async Task<IActionResult> AddEntityToDB(<#=entityName#>Dto newEntityDto)
    {
           
        <#=entityName#>Dto sanitizedNewDto = onSanitizeDto(newEntityDto);
            
        ProblemDetails validationProblem = onBeforeCreateValidation(sanitizedNewDto);
        if(validationProblem != null)
        {
            return Problem(validationProblem.Detail, validationProblem.Instance, validationProblem.Status, validationProblem.Title);
        }
            
        if (await db.<#= entityDbSetName #>.Where(<#= GetLinqWhereClause(entityType,"sanitizedNewDto") #>).SingleOrDefaultAsync() != null)
        {
            return Problem($"Duplicate trap, <#=entityName#> already exist.");                
        }
        var efModel = sanitizedNewDto.ToEfModel();
        db.<#= entityDbSetName #>.Add(efModel);
        await db.SaveChangesAsync();
        return Ok(efModel.ToDto());
        
    }




    /// <summary>
    /// Retrieves a list of all <#= entityDbSetName #>
    /// </summary>
    /// <returns>A collection of <#= entityName #> Dtos</returns>
    [HttpGet]
    [Route("api/<#= entityName #>/get-all-<#= entityName #>")]
    [RequireSecurityToken]
    [Produces(typeof(ICollection<<#=entityName#>Dto>))]
    public async Task<IActionResult> GetAllAsync()
    {
        var results = await db.<#= entityDbSetName #>.ToArrayAsync();
        return Ok(results.ToDto());
    }


    /// <summary>
    /// Retrieves <#= entityName #> by Id
    /// </summary>
    /// <returns><#= entityName #> Dto</returns>
    [HttpGet]
    [Route("api/<#= entityName #>/getbyId-<#= entityName #>")]
    [RequireSecurityToken]
    [Produces(typeof(<#=entityName#>Dto))]
    public async Task<IActionResult> GetByIdAsync(<#= BuildQueryParameters(entityType) #>)
    {
        var efEntity = await db.<#= entityDbSetName #>.Where(<#= GetLinqWhereClause(entityType) #>).SingleOrDefaultAsync();
        return Ok(efEntity.ToDto());
    }

    
    /// <summary>
    /// Updates  <#= entityName #> in the database
    /// </summary>
    /// <returns></returns>
    [HttpPut()]
    [Route("api/<#= entityName #>/update-<#= entityName #>")]
    [RequireSecurityToken()]
    [Produces(typeof( <#= entityName #>Dto))]
    public async Task<IActionResult> Update<#= entityName #>(<#= entityName #>Dto entityDto)
    {
        
        <#= entityName #>Dto originalEntityDto = null;
        
        originalEntityDto = (await db.<#= entityDbSetName #>.SingleOrDefaultAsync(<#=GetLinqWhereClause(entityType, "entityDto")#>)).ToDto();
        if(originalEntityDto == null)
        {
            return Problem("Can't update non-existent <#= entityName #>");
        }
        
        //Sanitize payload
        <#= entityName #>Dto sanitizedEntityDto = PreEntityUpdate(entityDto);
            
        //Fields to ignore when detecting changes
<#  foreach (var property in GetPrimaryKeys(entityType))
{  
#>
        sanitizedEntityDto.<#= property.Name #> = originalEntityDto.<#= property.Name #>;
<#
} 
#>
               
        //Merge original with changes incoming
        var updatedJObject = JObject.FromObject(originalEntityDto);
        updatedJObject.Merge(JObject.FromObject(sanitizedEntityDto));

        //Validate the update
        ProblemDetails validationProblem = onBeforeUpdateValidation(originalEntityDto, sanitizedEntityDto);
        if (validationProblem == null)
        {

            var jsonOriginalEntityInDBDto = JsonConvert.SerializeObject(originalEntityDto);
            var jsonUpdatedJObject = JsonConvert.SerializeObject(updatedJObject);
            if (jsonOriginalEntityInDBDto != jsonUpdatedJObject)
            {
                <#= entityName #> updatedEfEntity = updatedJObject.ToObject<<#= entityName #>Dto>().ToEfModel();
                db.Entry(updatedEfEntity);
                db.Entry(updatedEfEntity).State = EntityState.Modified;
                await db.SaveChangesAsync();
                return Ok(updatedEfEntity.ToDto());
            }
            return Problem("No change was detected!");
        }
        else
        {
            return Problem(validationProblem.Detail, validationProblem.Instance, validationProblem.Status, validationProblem.Title);
        }
           
    }
    <#}//End check for keyless (tables only)#> 
    

}//End Controller


//Controller Base Class
public abstract class <#= entityName #>ControllerBase: Controller
{
    /// <summary>
    /// Fires prior to saving  <#= entityName #> to DB. You can use this to sanitize the Dto eg assign Id, change value formatting etc
    /// </summary>
    /// <param name="newEntityDto"></param>
    /// <returns>New  <#= entityName #> dto representation to be persisted</returns>
    internal virtual <#= entityName #>Dto PreEntityCreation(<#= entityName #>Dto newEntityDto)
    {
        return newEntityDto;
    }

    /// <summary>
    /// Fires after <#= entityName #> is successfully persisted to database
    /// </summary>
    /// <param name="createdEntityDto"><#= entityName #>Dto created in DB</param>
    internal virtual void PostEntityCreation(<#= entityName #>Dto createdEntityDto)
    {
        return;
    }

    /// <summary>
    /// Fires prior to updating  <#= entityName #>. You can use this to sanitize the Dto eg assign Id, change value formatting etc
    /// </summary>
    /// <param name="updatedEntityDto"></param>
    /// <returns>New  <#= entityName #> dto representation to be persisted</returns>
    internal virtual <#= entityName #>Dto PreEntityUpdate(<#= entityName #>Dto updatedEntityDto)
    {
        return updatedEntityDto;
    }
    

    /// <summary>
    /// Fires before update. Use to validate old and new <#= entityName #>. 
    /// Return a problem if business logic is violated else return null;
    /// </summary>
    /// <param name="updatedEntityDto"></param>
    internal virtual ProblemDetails onBeforeUpdateValidation(<#= entityName #>Dto oldDto, <#= entityName #>Dto newDto)
    {
        return null;
    }


    internal virtual <#=entityName#>Dto onSanitizeDto(<#=entityName#>Dto newEntityDto){
        return newEntityDto;
    }

    
    internal virtual ProblemDetails onBeforeCreateValidation(<#=entityName#>Dto sanitizedNewDto){
        return null;
    }
    
}


//Define Data Transfer Object
public class <#= entityName #>Dto
{
<#foreach (var property in entityType.GetProperties())
{
    if (entityType.FindNavigation(property.Name) == null)
    {
        var typeName = property.GetTypeMapping().ClrType.Name;
        var nullable = property.IsNullable ? "?" : "";
#>
    public <#= typeName #><#= nullable #> <#= property.Name #> { get; set; }
<#    }
}
#>
}


//Define extensions for converting efEntities to Dtos and vice versa
internal static class <#= entityName #>ConversionExtensions
{
    internal static <#= entityName #>Dto ToDto(this <#= entityName #> sourceEfModel)
    {
        if(sourceEfModel == null)
        {
            return null;
        }
        <#= entityName #>Dto dto = new <#= entityName #>Dto();
<#foreach (var property in entityType.GetProperties())
{
    if (entityType.FindNavigation(property.Name) == null)
    {
        var typeName = property.GetTypeMapping().ClrType.Name;
        var nullable = property.IsNullable ? "?" : "";
#>
        dto.<#= property.Name #> = sourceEfModel.<#= property.Name #>;
<#  
    }
}
#>
        return dto;
    }

    internal static <#= entityName #> ToEfModel(this <#= entityName #>Dto sourceDto)
    {
        if(sourceDto == null)
        {
            return null;
        }
        <#= entityName #> efModel = new <#= entityName #>();
<#foreach (var property in entityType.GetProperties())
{
    if (entityType.FindNavigation(property.Name) == null)
    {
        var typeName = property.GetTypeMapping().ClrType.Name;
        var nullable = property.IsNullable ? "?" : "";
#>
        efModel.<#= property.Name #> = sourceDto.<#= property.Name #>;
<#  
    }
}
#>
        return efModel;
    }

    internal static List<<#= entityName #>Dto> ToDto(this ICollection<<#= entityName #>> source)
    {
        List <<#= entityName #>Dto> dtos = new List <<#= entityName #>Dto>();
        foreach (var element in source)
        {
            dtos.Add(element.ToDto());
        }
        return dtos;
    }

    internal static List<<#= entityName #>> ToEfModel(this ICollection<<#= entityName #>Dto> source)
    {
        List<<#= entityName #>> dtos = new List<<#= entityName #>>();
        foreach (var element in source)
        {
            dtos.Add(element.ToEfModel());
        }
        return dtos;
    }


}




<#+
    private string GetLinqWhereClause(IEntityType entityType, string dtoVarName)
    {
        List<string> conditions = new List<string>();
        foreach (var pk in GetPrimaryKeys(entityType)){
            conditions.Add($"r.{pk.Name} == {dtoVarName}.{pk.Name}");
        }
        return "r => " + string.Join(" && ", conditions);
    }

    private string GetLinqWhereClause(IEntityType entityType)
    {
        List<string> conditions = new List<string>();
        foreach (var pk in GetPrimaryKeys(entityType)){
            conditions.Add($"r.{pk.Name} == {pk.Name}");
        }
        return "r => " + string.Join(" && ", conditions);
    }

     private string BuildQueryParameters(IEntityType entityType)
    {
        List<string> queryParams = new List<string>();
        foreach (var pk in GetPrimaryKeys(entityType)){
            var typeName = pk.GetTypeMapping().ClrType.Name;
            queryParams.Add($"[FromQuery]{typeName} {pk.Name}");
        }
        return string.Join(", ", queryParams);
    }

    private List<IProperty> GetPrimaryKeys(IEntityType entityType)
    {
        List<IProperty> primaryKeys = new List<IProperty>();
        foreach (var property in entityType.GetProperties())
        {
            if (property.IsPrimaryKey())
            {
                primaryKeys.Add(property);
            }
        }
        return primaryKeys;
    }

#>